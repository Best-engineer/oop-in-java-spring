# Chapter2 자바와 절차적/구조적 프로그래밍 

## 자바 프로그램의 개발과 구동: 현실 세계와 가상 세계 비교

자바(Java)는 **가상 세계(Java World)**를 만들어

현실 세계(컴퓨터 환경)의 구조를 그대로 모방해 놓은 언어입니다.

아래는 두 세계의 1:1 대응 개념입니다.

  현실 세계 ↔ 가상 세계(Java World)

| **현실 세계** | **가상 세계(Java World)** | 설명 |
| --- | --- | --- |
| **소프트웨어 개발 도구** | **JDK (Java Development Kit)** | 자바 코드를 컴파일·패키징하는 개발 도구 모음. 컴파일러 `javac` 포함. |
| **운영체제(OS)** | **JRE (Java Runtime Environment)** | 자바 프로그램이 돌아가는 *자바용 운영체제*. |
| **하드웨어(물리적 컴퓨터)** | **JVM (Java Virtual Machine)** | 자바 프로그램을 실행하는 *가상 컴퓨터*. JRE 내부에 포함. |

## JDK = 자바 개발 도구(개발자용)

현실 세계에서 “Visual Studio / GCC 컴파일러 / 빌드 툴” 같은 역할.

- 컴파일러(`javac`)
- jlink, javadoc
- 디버깅 툴
- JRE 포함

➡ **개발자는 JDK를 사용해서 코드를 작성하고 컴파일한다.**

## JRE = 자바 실행 환경(사용자용)

현실 세계의 운영체제처럼

자바 프로그램이 돌아가기 위해 필요한 **표준 API + JVM + 라이브러리** 포함.

➡ 실행만 하는 사용자라면 JRE만 있어도 됨.

(요즘은 JDK에 JRE가 포함되어 별도 설치 필요 거의 없음)

## JVM = 자바 가상 기계(가상의 컴퓨터)

현실 세계의 “물리적 CPU + 메모리” 역할을 대신함.

- 바이트코드 해석 또는 JIT 컴파일
- 메모리 관리(GC)
- 스레드 스케줄링
- 예외 처리

➡ JVM 덕분에 **자바는 OS에 상관없이 실행되는 WORA(Write Once, Run Anywhere)**를 실현.

## 전체 구조 흐름

```
현실 세계(물리적 컴퓨터)
 → OS
   → JDK (개발 시)
   → JRE (실행 시)
     → JVM (자바 프로그램 실행)
       → Bytecode 실행(.class)

```

자바 월드는 현실 세계의 구조를 계층적으로 모방한 체계이다.

---

## 프로그램 실행 시 메모리 사용 방식과 자바의 메모리 구조(T 메모리 구조)

자바 프로그램은 실행될 때 **JRE(실행환경)**가 준비되고, 그 안에서 **JVM(가상 컴퓨터)**가 동작하며 프로그램을 실행한다.

JVM은 프로그램을 실행하기 위해 **특정한 메모리 구조(T 메모리 구조)**를 사용한다.

---

## 메모리 구조 (코드 실행 + 데이터 저장 영역)

### 데이터 저장 영역

JVM 메모리의 핵심이며 아래의 3구역으로 나뉜다.

### 스태틱 영역 (클래스들의 놀이터)

- 클래스 정보, static 변수, static 메서드 저장
- 프로그램 종료까지 살아있음
- 모든 스레드가 공유

### 스택 영역 (메서드들의 놀이터)

- 메서드 실행 시 **스택 프레임(Stack Frame)** 생성
- 지역변수, 매개변수 저장
- 메서드 종료 시 프레임 통째로 제거
- 스레드마다 독립된 스택을 가짐

### 힙 영역 (객체들의 놀이터)

- new로 생성된 객체 저장
- 모든 스레드가 공유
- 더 이상 사용되지 않는 객체는 GC가 수거

---

## 간단한 “Hello World” 출력까지의 메모리 진행 순서

### 1) JVM 시작

OS가 JRE 실행 → JVM 구동 → T 메모리 구조 준비됨

### 2) Hello.class 로드 → 스태틱 영역

- 클래스 정보 올라옴
- main() 메서드 위치 기록
- System.out.println() 등 java.lang 패키지 클래스들도 같이 로드됨
    
    (java.lang은 자동 import)
    

### 3) main() 호출 → 스택 영역에 메서드 스택 프레임 생성

스택 프레임 구성:

- 매개변수(String[] args)
- 지역변수
- return 주소

### 4) println 실행 → 힙과 스태틱 이용

- System 클래스는 스태틱 영역에 존재
- System.out 객체는 힙에 존재
- out.println("Hello World") 실행

### 5) main() 종료 → 스택 프레임 제거

- main() 프레임이 메모리에서 사라짐

### 6) 모든 작업 종료 → JVM 종료

- 스태틱·힙 영역 메모리 해제
- JRE·JVM 프로세스 자체도 OS에서 사라짐

---

## java.lang 패키지, import 패키지, 클래스들

### java.lang 패키지

- String, System, Thread 등 필수 요소
- 자동 import (import 필요 없음)
- 프로그램 실행 시 가장 먼저 로드되는 기본 패키지

### import 패키지

- java.util.*, java.io.*, java.net.* 같은 추가 기능 패키지
- 사용하려면 import 필요

---

## 변수와 메모리

### 지역 변수

- 메서드 스택 프레임에 저장
- 메서드 끝나면 통째로 사라짐

### 멤버 변수(필드)

- 객체 소속 → 힙 영역에 저장
- 객체가 GC되면 사라짐

### static 변수

- 클래스 소속 → 스태틱 영역에 저장
- 프로그램 종료 시까지 유지

---

## 블록 구문과 메모리

```java
{
    int x = 10;
}

```

- 블록 내부 지역 변수는 **그 블록을 빠져나가면서 사라짐**
- 단, 스택 프레임 전체는 메서드가 끝날 때 제거되므로
    
    블록 내부 변수는 사실상 “해당 블록 범위 안에서만 유효”
    

---

## 메서드 호출과 메모리 (스택 프레임)

메서드를 부를 때마다 스택에 **새로운 프레임**이 쌓임.

```
메서드 A → 메서드 B → 메서드 C
스택 구조:
C (top)
B
A (bottom)

```

메서드 종료하면 프레임 제거(pop)

---

## 메서드 블랙박스화

- 메서드 내부의 지역변수는 **외부에서 절대 볼 수 없음**
- 메서드 간 전달되는 정보는 **매개변수 & return 값뿐**
- 이를 “블랙박스화”라고 부름
    
    → 내부구현은 감추고, 입력/출력만 노출
    

---

## 전역 변수와 메모리, 왜 쓰면 안 좋은가?

자바는 **전역 변수 자체가 없음**

하지만 static 변수를 사실상 전역처럼 사용할 수 있다.

문제점:

- 여러 메서드, 여러 클래스가 동시에 접근 → 유지보수 어렵다
- 멀티스레드 환경에서 충돌 위험 → 동기화 문제 발생
- 예상하지 못한 값 변경으로 버그 발생 가능

그래서 권장 X

→ 객체의 필드 또는 메서드 파라미터 활용이 더 안전

---

## 멀티스레드 & 멀티프로세스

### 멀티스레드

- 하나의 JVM(T 메모리 구조)을 여러 스레드가 공유
- **스택만 스레드별로 분리**,
- 스태틱, 힙은 전부 공유

장점:

- 메모리 적게 사용
- 스레드 간 데이터 공유 용이
- 빠른 전환(Context Switching 비용 적음)

단점:

- 공유 자원 동기화 필요 (race condition 발생 위험)

---

### 멀티프로세스

- 프로세스마다 JVM(T 메모리) 전체가 따로 생김
- 메모리 독립 → 안전
- 하지만 자원 소모 큼 (힙/스태틱 모두 따로)

---

## 멀티스레드와 웹 프로그래밍 연결

웹 서버는

- 요청 1개당 프로세스를 생성하면 **너무 무거움**
- 대신 요청 1개당 **스레드** 배정 → 훨씬 효율적

---

## 자바에서 “요청당 프로세스가 아닌 요청당 스레드”의 의미

### 서블릿 컨테이너(톰캣 등)의 방식

- **HTTP 요청 1개 = 스레드 1개** 할당
- 스레드는 JVM 안에서 돌아가므로
    
    “T 메모리를 하나만” 사용
    
- 힙/스태틱은 공유하므로 여러 요청 처리 시 매우 효율적

### 왜 효율적인가?

- 프로세스 생성보다 스레드 생성 비용이 훨씬 적음
- 프로세스는 메모리 차지량이 큼
- 스레드는 스택만 별도로 갖기 때문에 가볍다
- 동시에 여러 요청을 처리할 수 있다

---

## 전체 요약

- 자바 프로그램은 JVM에서 T 메모리 구조(스태틱/스택/힙)를 사용
- Hello World 실행 과정은 “클래스 로딩 → 스택 프레임 → println 실행” 순
- main() 종료 후 JVM 종료
- 변수는 저장되는 위치에 따라 생명주기 다름
- 메서드 호출 시 스택 프레임 구조 사용
- 메서드 내부 변수는 외부에서 보이지 않음
- 전역 변수는 문제를 일으킬 수 있으므로 지양
- 멀티스레드는 한 JVM 내에서 스택만 분리된 구조
- 웹에서는 요청당 스레드를 쓰기 때문에 매우 효율적

---

# ✅ 1. 자바에는 왜 전역 변수가 없을까?

자바는 **객체지향 언어**라서 모든 변수는 반드시 **클래스 안에 위치**해야 한다.

C처럼 클래스 밖에 “전역 변수”를 선언하는 문법 자체가 없다.

✔ 이유

- 자바는 코드 구조를 **클래스 단위로만 구성**
- 클래스 외부 영역에 변수를 둘 수 없음
- 변수 접근은 항상 “객체 또는 클래스명”을 통해서만

👉 즉, **언어 설계 차원에서 전역 변수를 허용하지 않음**

---

# ✅ 2. 그렇다면 전역 변수 역할을 하고 싶은 경우?

바로 **static 변수(클래스 변수)**가 전역 변수처럼 동작한다.

```java
class Counter {
    static int total = 0;  // 전역처럼 사용 가능
}

```

누구나 다음처럼 접근:

```java
Counter.total = 10;
System.out.println(Counter.total);

```

✔ 특징

- 프로그램 전체에서 공유됨
- 객체를 만들지 않아도 접근 가능
- 한 번만 메모리에 올라감

→ **전역 변수와 동일한 역할**

---

# ✅ 3. static 변수가 전역 변수와 다른 점

| 구분 | C의 전역 변수 | 자바 static 변수 |
| --- | --- | --- |
| 위치 | 함수/클래스 밖 전역 공간 | 클래스 내부 |
| 메모리 | 전역 영역 | 메서드 영역(Method Area) |
| 접근 방식 | 이름 그대로 접근 | `클래스명.변수명` 으로 접근 |
| 설계 철학 | 절차 중심 | 객체 중심 |

자바의 static 변수는 “전역처럼 보이지만”

**반드시 클래스 안에 포함되어 있다는 점**이 다름.

---

# ✅ 4. 간단 예시

```java
class Config {
    static String appName = "My App";     // 전역 변수처럼 사용
}

public class Main {
    public static void main(String[] args) {
        System.out.println(Config.appName);  // 어디서나 접근 가능
    }
}

```

---

# 📌 한 줄 요약

**자바에는 문법적 전역 변수는 없지만, “static 변수”가 전역 변수 역할을 대신한다.**

---

---

# ✅ **C 언어의 전역 변수 예시**

```c
#include <stdio.h>

// 🔹 전역 변수 (Global Variable)
int counter = 0;

void increase() {
    counter++;   // 전역 변수 직접 사용
}

int main() {
    printf("초기 counter: %d\n", counter);

    increase();
    increase();

    printf("increase() 호출 후 counter: %d\n", counter);
    return 0;
}

```

---

# 📌 **실행 결과**

```
초기 counter: 0
increase() 호출 후 counter: 2

```

---

# 🔍 **해설**

### ✔ 1. 전역 변수의 특징

- 함수 바깥에 선언됨
- 파일 전체에서 접근 가능
- 메모리의 **전역 영역(Global Area)**에 저장됨
- 프로그램 실행 동안 유지됨

### ✔ 2. 자바와의 차이

| 언어 | 전역 변수 위치 | 문법 지원 여부 |
| --- | --- | --- |
| **C** | 함수 밖 전역 영역(Global Area) | O (존재) |
| **Java** | 클래스 밖에 변수를 선언할 수 없음 | X (전역 변수 없음) |

자바는 아래처럼 절대 작성 불가:

```java
int x = 10;  // ❌ 클래스 밖이라 불가능
class Test {}

```

그래서 자바는 대신 이렇게 사용:

```java
class Test {
    static int x = 10;   // static 변수 = 전역처럼 사용
}

```

---

겉보기에는 **자바의 static 변수 = C의 전역 변수처럼 보이지만**,

내부 철학과 동작 방식은 꽤 많이 다릅니다.

아래에서 **핵심 차이 5가지**를 정확하고 깔끔하게 정리해줄게.

# ✅ 1. **static 변수는 “클래스 소속”, 전역 변수는 “파일(프로그램) 소속”**

### ✔ C 전역 변수

- 클래스 개념 없음
- **파일 자체**(전역 영역)에 속함
- 프로그램 전체의 전역 데이터

### ✔ Java static 변수

- 반드시 **클래스 내부에 존재**해야 함
- 클래스가 로딩되면 생성됨
- "클래스가 가진 공유 데이터"

➡ 즉 정체성 자체가 다름

➡ Java는 “클래스 밖 어떤 변수도 존재할 수 없음”

---

# ✅ 2. **접근 방식이 의도적으로 제한됨**

### ✔ C 전역 변수

```c
counter = 10;   // 어디서나 변수명으로 접근

```

- 이름만 알면 접근 가능
- 구조적 제약이 적음 → 실수·충돌 위험 있음

### ✔ Java static 변수

```java
Counter.total = 10;   // 클래스명을 통해 접근

```

- 반드시 **클래스명.변수명**
- 더 안전하고, 소속이 명확함

➡ Java는 구조적으로 “아무데서나 접근”을 **강제로 방지**함

➡ 접근 제어자도 적용됨 (public, private, etc.)

---

# ✅ 3. **접근 제어자(캡슐화) 사용 여부**

### ✔ C 전역 변수

- 접근 제어자 없음
- 파일 전체에서 공유
- 외부 파일에서도 `extern`으로 끌어올 수 있음

### ✔ Java static 변수

- 접근 제어자 적용됨

```java
public static int a;     // 모두 접근
private static int b;    // 클래스 내부만

```

➡ Java는 static 변수라도 **캡슐화/정보은닉**이 가능

➡ C 전역 변수는 제어가 거의 불가능

---

# ✅ 4. **메모리 모델 차이**

| 구분 | 저장 위치 | 특성 |
| --- | --- | --- |
| **C 전역 변수** | 전역 영역(Global Area) | 프로그램 전체 공유, 파일 스코프 |
| **Java static 변수** | 메서드 영역(Method Area) | 클래스 로딩 시 생성, JVM이 관리 |

➡ 둘 다 하나만 존재하지만 위치가 다르고 관리 방식도 다름

➡ Java는 JVM이 로딩/언로드까지 관리

## 💻 프로그램 메모리 영역 비교

사용자님께서 언급하신 프로그램의 메모리 영역 구분은 **매우 일반적이고 정확한 개념**입니다. 다만, 자바의 JVM 환경에서는 명칭을 JVM 표준에 맞춰 부릅니다.

| **사용자님의 용어 (일반적)** | **JVM 메모리 영역 표준 용어** | **주요 저장 대상** | **특징** |
| --- | --- | --- | --- |
| **실행 영역** | **PC Register / Native Method Stack** | 현재 실행할 명령어의 주소, 네이티브 메서드 정보 등 | 스레드별 독립 공간 |
| **데이터 저장 영역 (정적)** | **Method Area** (메서드 영역) | **`static` 변수**, 클래스 및 메서드 메타데이터 | 모든 스레드 공유 |
| **데이터 저장 영역 (동적)** | **Heap Area** (힙 영역) | **모든 객체(인스턴스)** 및 배열의 실제 데이터 | 모든 스레드 공유 |
| **데이터 저장 영역 (지역)** | **Stack Area** (스택 영역) | 메서드 내 **지역 변수**, 매개변수, 메서드 호출 정보 | 스레드별 독립 공간 |

---

# ✅ 5. **언어 철학의 본질적 차이**

### ✔ C

- 절차적 언어
- “필요하면 어디서나 꺼내 쓰는” 전역 변수 존재
- 프로그램 전체에서 접근 가능한 개념 필요했음

### ✔ Java

- 객체지향 언어
- 모든 데이터는 반드시 클래스 내부에 있어야 함
- 설계 자체가 “전역 변수 금지”

➡ static은 “전역처럼 보이지만 전역은 아님”

➡ 객체지향 원칙을 유지하기 위한 대체 수단

---

# 📌 핵심 요약 5줄

1. **static 변수는 클래스 소속** — 전역 변수는 파일/프로그램 소속
2. static은 **클래스명.변수명**으로 접근해야 함
3. static은 **캡슐화·접근 제어자** 적용 가능 → 전역은 불가능
4. 메모리 구조도 다름
5. static은 객체지향에서 전역 역할을 하기 위한 **제한된 전역성**

---

# 📌 결론

**static 변수는 “전역처럼 쓸 수 있는 클래스 변수”지,
C의 진짜 전역 변수와는 접근 범위·철학·메모리 구조가 다르다.**