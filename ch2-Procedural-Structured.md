# Chapter2 자바와 절차적/구조적 프로그래밍 

## 자바 프로그램의 개발과 구동: 현실 세계와 가상 세계 비교

자바(Java)는 **가상 세계(Java World)**를 만들어

현실 세계(컴퓨터 환경)의 구조를 그대로 모방해 놓은 언어입니다.

아래는 두 세계의 1:1 대응 개념입니다.

  현실 세계 ↔ 가상 세계(Java World)

| **현실 세계** | **가상 세계(Java World)** | 설명 |
| --- | --- | --- |
| **소프트웨어 개발 도구** | **JDK (Java Development Kit)** | 자바 코드를 컴파일·패키징하는 개발 도구 모음. 컴파일러 `javac` 포함. |
| **운영체제(OS)** | **JRE (Java Runtime Environment)** | 자바 프로그램이 돌아가는 *자바용 운영체제*. |
| **하드웨어(물리적 컴퓨터)** | **JVM (Java Virtual Machine)** | 자바 프로그램을 실행하는 *가상 컴퓨터*. JRE 내부에 포함. |

## JDK = 자바 개발 도구(개발자용)

현실 세계에서 “Visual Studio / GCC 컴파일러 / 빌드 툴” 같은 역할.

- 컴파일러(`javac`)
- jlink, javadoc
- 디버깅 툴
- JRE 포함

➡ **개발자는 JDK를 사용해서 코드를 작성하고 컴파일한다.**

## JRE = 자바 실행 환경(사용자용)

현실 세계의 운영체제처럼

자바 프로그램이 돌아가기 위해 필요한 **표준 API + JVM + 라이브러리** 포함.

➡ 실행만 하는 사용자라면 JRE만 있어도 됨.

(요즘은 JDK에 JRE가 포함되어 별도 설치 필요 거의 없음)

## JVM = 자바 가상 기계(가상의 컴퓨터)

현실 세계의 “물리적 CPU + 메모리” 역할을 대신함.

- 바이트코드 해석 또는 JIT 컴파일
- 메모리 관리(GC)
- 스레드 스케줄링
- 예외 처리

➡ JVM 덕분에 **자바는 OS에 상관없이 실행되는 WORA(Write Once, Run Anywhere)**를 실현.

## 전체 구조 흐름

```
현실 세계(물리적 컴퓨터)
 → OS
   → JDK (개발 시)
   → JRE (실행 시)
     → JVM (자바 프로그램 실행)
       → Bytecode 실행(.class)

```

자바 월드는 현실 세계의 구조를 계층적으로 모방한 체계이다.

---

## 프로그램 실행 시 메모리 사용 방식과 자바의 메모리 구조(T 메모리 구조)

자바 프로그램은 실행될 때 **JRE(실행환경)**가 준비되고, 그 안에서 **JVM(가상 컴퓨터)**가 동작하며 프로그램을 실행한다.

JVM은 프로그램을 실행하기 위해 **특정한 메모리 구조(T 메모리 구조)**를 사용한다.

---

## 메모리 구조 (코드 실행 + 데이터 저장 영역)

### 데이터 저장 영역

JVM 메모리의 핵심이며 아래의 3구역으로 나뉜다.

### 스태틱 영역 (클래스들의 놀이터)

- 클래스 정보, static 변수, static 메서드 저장
- 프로그램 종료까지 살아있음
- 모든 스레드가 공유

### 스택 영역 (메서드들의 놀이터)

- 메서드 실행 시 **스택 프레임(Stack Frame)** 생성
- 지역변수, 매개변수 저장
- 메서드 종료 시 프레임 통째로 제거
- 스레드마다 독립된 스택을 가짐

### 힙 영역 (객체들의 놀이터)

- new로 생성된 객체 저장
- 모든 스레드가 공유
- 더 이상 사용되지 않는 객체는 GC가 수거

---

## 간단한 “Hello World” 출력까지의 메모리 진행 순서

### 1) JVM 시작

OS가 JRE 실행 → JVM 구동 → T 메모리 구조 준비됨

### 2) Hello.class 로드 → 스태틱 영역

- 클래스 정보 올라옴
- main() 메서드 위치 기록
- System.out.println() 등 java.lang 패키지 클래스들도 같이 로드됨
    
    (java.lang은 자동 import)
    

### 3) main() 호출 → 스택 영역에 메서드 스택 프레임 생성

스택 프레임 구성:

- 매개변수(String[] args)
- 지역변수
- return 주소

### 4) println 실행 → 힙과 스태틱 이용

- System 클래스는 스태틱 영역에 존재
- System.out 객체는 힙에 존재
- out.println("Hello World") 실행

### 5) main() 종료 → 스택 프레임 제거

- main() 프레임이 메모리에서 사라짐

### 6) 모든 작업 종료 → JVM 종료

- 스태틱·힙 영역 메모리 해제
- JRE·JVM 프로세스 자체도 OS에서 사라짐

---

## java.lang 패키지, import 패키지, 클래스들

### java.lang 패키지

- String, System, Thread 등 필수 요소
- 자동 import (import 필요 없음)
- 프로그램 실행 시 가장 먼저 로드되는 기본 패키지

### import 패키지

- java.util.*, java.io.*, java.net.* 같은 추가 기능 패키지
- 사용하려면 import 필요

---

## 변수와 메모리

### 지역 변수

- 메서드 스택 프레임에 저장
- 메서드 끝나면 통째로 사라짐

### 멤버 변수(필드)

- 객체 소속 → 힙 영역에 저장
- 객체가 GC되면 사라짐

### static 변수

- 클래스 소속 → 스태틱 영역에 저장
- 프로그램 종료 시까지 유지

---

## 블록 구문과 메모리

```java
{
    int x = 10;
}

```

- 블록 내부 지역 변수는 **그 블록을 빠져나가면서 사라짐**
- 단, 스택 프레임 전체는 메서드가 끝날 때 제거되므로
    
    블록 내부 변수는 사실상 “해당 블록 범위 안에서만 유효”
    

---

## 메서드 호출과 메모리 (스택 프레임)

메서드를 부를 때마다 스택에 **새로운 프레임**이 쌓임.

```
메서드 A → 메서드 B → 메서드 C
스택 구조:
C (top)
B
A (bottom)

```

메서드 종료하면 프레임 제거(pop)

---

## 메서드 블랙박스화

- 메서드 내부의 지역변수는 **외부에서 절대 볼 수 없음**
- 메서드 간 전달되는 정보는 **매개변수 & return 값뿐**
- 이를 “블랙박스화”라고 부름
    
    → 내부구현은 감추고, 입력/출력만 노출
    

---

## 전역 변수와 메모리, 왜 쓰면 안 좋은가?

자바는 **전역 변수 자체가 없음**

하지만 static 변수를 사실상 전역처럼 사용할 수 있다.

문제점:

- 여러 메서드, 여러 클래스가 동시에 접근 → 유지보수 어렵다
- 멀티스레드 환경에서 충돌 위험 → 동기화 문제 발생
- 예상하지 못한 값 변경으로 버그 발생 가능

그래서 권장 X

→ 객체의 필드 또는 메서드 파라미터 활용이 더 안전

---

## 멀티스레드 & 멀티프로세스

### 멀티스레드

- 하나의 JVM(T 메모리 구조)을 여러 스레드가 공유
- **스택만 스레드별로 분리**,
- 스태틱, 힙은 전부 공유

장점:

- 메모리 적게 사용
- 스레드 간 데이터 공유 용이
- 빠른 전환(Context Switching 비용 적음)

단점:

- 공유 자원 동기화 필요 (race condition 발생 위험)

---

### 멀티프로세스

- 프로세스마다 JVM(T 메모리) 전체가 따로 생김
- 메모리 독립 → 안전
- 하지만 자원 소모 큼 (힙/스태틱 모두 따로)

---

## 멀티스레드와 웹 프로그래밍 연결

웹 서버는

- 요청 1개당 프로세스를 생성하면 **너무 무거움**
- 대신 요청 1개당 **스레드** 배정 → 훨씬 효율적

---

## 자바에서 “요청당 프로세스가 아닌 요청당 스레드”의 의미

### 서블릿 컨테이너(톰캣 등)의 방식

- **HTTP 요청 1개 = 스레드 1개** 할당
- 스레드는 JVM 안에서 돌아가므로
    
    “T 메모리를 하나만” 사용
    
- 힙/스태틱은 공유하므로 여러 요청 처리 시 매우 효율적

### 왜 효율적인가?

- 프로세스 생성보다 스레드 생성 비용이 훨씬 적음
- 프로세스는 메모리 차지량이 큼
- 스레드는 스택만 별도로 갖기 때문에 가볍다
- 동시에 여러 요청을 처리할 수 있다

---

## 전체 요약

- 자바 프로그램은 JVM에서 T 메모리 구조(스태틱/스택/힙)를 사용
- Hello World 실행 과정은 “클래스 로딩 → 스택 프레임 → println 실행” 순
- main() 종료 후 JVM 종료
- 변수는 저장되는 위치에 따라 생명주기 다름
- 메서드 호출 시 스택 프레임 구조 사용
- 메서드 내부 변수는 외부에서 보이지 않음
- 전역 변수는 문제를 일으킬 수 있으므로 지양
- 멀티스레드는 한 JVM 내에서 스택만 분리된 구조
- 웹에서는 요청당 스레드를 쓰기 때문에 매우 효율적