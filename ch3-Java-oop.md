# Chapter3 자바와 객체 지향

## 객체지향은 인간 지향이다. 

- 세상에 존재하는 모든 것은 사물, 즉 객체(object)다.
- 각각의 사물은 고유하다.
- 사물은 속성을 갖는다. (property)
- 사물은 행위를 한다. (method)

그리고 사물을 하나하나 이해하기 보다는 사물을 분류(class)해서 이해하는 것이 인간의 인지법이다. 
- 직립보행을 하며 말을 하는 존재를 사람이라고 분류한다.
- 밤하늘에 반짝이는 사물들을 별이라고 분류한다. 

김종민, 한효주(object)라고 하는 존재는 사람이라는 분류에 속한다. 그리고 사람이라는 분류 안의 객체(object)들은 나이, 몸무게, 키 등의 속성과 
먹다, 자다, 울다, 싸다 등의 행위(method)를 가지고 있다.

## 객체 지향의 4대 특성 - 캠! 상추다

# 클래스 vs 객체 = 붕어빵틀 vs 붕어빵??

- 클래스 객체명 = new 클래스();
- 금형기계 붕어빵틀 = new 금형기계(); -> 새로운 금형기계를 하나 만들었더니 붕어빵틀이 되었다??
# 클래스명은 분류스럽게, 객체 참조 변수명은 유일무이한 사물처럼 작명하기!

# 클래스는 분류에 대한 개념이지 실체가 아니다. 

- 김연아는 클래스 인가? 객체인가?
- 팽귄은 클래스 인가? 객체인가?
- 뽀로로는 클래스 인가? 객체인가?
- 클래스와 객채를 구분하는 방법! -> 나이를 물어본다. -> 김연아와 뽀로로는 객체이고 팽귄은 클래스다! 

# 추상화 : 모델링 

- 추상화란 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합하는 것이다. 

객체 지향 4대 특성은 객체와 클래스를 통해 구현된다. 그래서 객체와 클래스를 먼저 알아보겠다. 
- 객체: 세상에 존재하는 유일무이한 사물, 생물이건 무생물이건 속성과 기능을 가지고 있다. 
- 클래스: 분류 , 집합, 같은 속성와 기능을 가진 객체를 총칭하는 개념
- 예를들어 홍길동이라는 새로운 사람이 태어났다. -> 사람 홍길동 = new 사람();
  - 사람이라는 클래스(분류)를 이용해 유일무이하고 새로운 하나의 **사람(객체)** 을 만들어 **홍길동(객체 참조 변수)** 이라는 이름을 지어준 것이다. 
  - 그런데 클래스를 이용해서 object를 만들었다는 것을 강조할 때 object 표현보다는 클래스의 인스턴스(instance)라는 표현을 쓴다. 
  
# 클래스는 객체의 설계도이기 때문에, 우리는 oop를 할 때 클래스를 먼저 설계한다.
- 예를들어, 사람이라는 클래스를 설계할 경우, 주변에서 보이는 사람의 실체들 즉, 객체들을 관찰해서 공동된 특성을 찾는다.
- 하지만 모든 특성을 넣을 필요가 있을까? 
  - 애플리케이션 경계(context)에 따라서 클래스가 달라진다. 
  - 예를들어, 병원 애플리케이션을 만든다면? 또는 은행 애플리케이션을 만든다면? -> 클래스의 설계도도 달라질 것이다. 
  - 추상화란 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합하는 것이라고 했다. -> 모델링

# 모델은 실제 사물을 정확히 복제하는 게 아니라 목적에 맞게 관심 있는 특성만을 추출해서 표현하는 것이다. 
# 모델은 추상화를 통해 실제 사물을 단순하게 묘사하는 것이다. 
- oop에서 클래스를 설계할 때 필요한 기법이고, 데이터베이스의 테이블을 설계할 때 필요한 기법이다. 

# 객체지향에서 추상화의 결과는 클래스다!! 
- 상속을 통한 추상화, 구체화
- 인터페이스를 통한 추상화
- 다형성을 통한 추상화
  
## 자바는 객체 지향의 추상화를 어떻게 지원 하고 있는가? -> 바로 class 키워드를 통해 지원하고 있다!!. 꼭 기억!!
- 추상화 = 모델링 = 자바의 class  키워드

# 그럼 클래스와 객체 관계를 자바에서는 어떻게 표현?
- 클래스 객체_참조_변수 = new 클래스(); -> 새로운 객체를 하나 생성해 그 객체의 주소값(포인터)를 객체 참조 변수에 할당. 

## 추상화와 T 메모리
# 클래스 맴버 = static 멤버 = 정적 멤버
# 객체 멤버 = 인스턴스 멤버 = 오브젝트 멤버
# 필드 = 속성 = 프로퍼티
# 함수 = 메소드
# 정적 메서드는 언제 사용 것이 좋을까? UML 표기할 때 밑줄이 있음
- 정적 메서드는 객체들의 존재 여부에 관계없이 쓸 수 있는 메서드다. 정적 멤버들은 객체가 아닌 클래스에 속해 있고, 클래스는 JVM 구동 시 T 메모리의 스태틱 영역에 바로 배치 되기 때문에 
  객체의 존재 여부에 관계 없이 쓸 수 있다. 
- main() 메서드는 당연히 정적 메서드여야 한다. 
- main() 메서드의 논리르 함수로 분할 해서 사용하는 경우
- 정적 변수에 대한 접근자 메서드(getter)와 설정자 메서드(setter)로 사용하는 용도 
- 유틸리티성 메서드(예를들어 Math 클래스에 있는 수많은 정적 메서드)

# 중요한 사실! 정적 속성인 경우 T 메모리의 스태틱 영역에 클래스가 배치될 때 내부에 메모리 공간이 확보됨
# 객체 속성은 속성며안 있지 실제 메모리 공간은 확보하지 않음. 객체 속성은 힙 영역에 객체가 생성되면 바로 그 때 각 객체안에 멤버 속성을 위한 메모리 공간이 할당 된다. 

# 스택 영역에 생기는 지역 변수는 개발자가 별도로 초기화 해주지 않으면 쓰레기가 된다. 
# 지역변수는 별도로 초기화해야 하는데 멤버변수(속성)은 왜 자동으로 초기화 해줄까? -> 지역변수는 한 지역에서만 쓰는 변수지만 멤버변수는 공유 변수의 성격을 가지고 있기 때문이다. 
- 객체 변수는 하나의 객체 안에서 다수의 객체 메서드가 공유하는 변수 이고, 클래스 변수는 전역 변수로서 프로그램 어디서든 접근 가능한 공유 변수다. 
- 이런 공유 변수 초기화는 누가 해야 할까?
- 객체 멤버인 경우는 생성자를 통해서, 정적 멤버는 정적 실행 영역을 통해 초기화하는 경우가 있긴 하지만 공유 변수를 딱히 누가 초기화해야 한다고 규정할 수는 없다. 
- 그래서 공유 변수는 별도로 초기화를 해주지 않아도 기본값으로 초기화되는 것이다. 
  
| 사람이 쓰는 이름 | 다른 이름 | 사는 곳(메모리) |
| --- | --- | --- |
| static 변수 | 클래스 변수 | 메서드 영역(Method Area) |
| 인스턴스 변수 | 필드, 멤버 변수 | 힙(Heap) |
| 지역 변수 | 매개 변수 | 스택(Stack) |


## 상속 = 재사용 + 확장 = 분류
# 자바 언어에서 inheritance 키워드는 존재 하지 않는다. -> extends(확장)이 존재 한다.

# 상위 클래스에서만 메서드를 구현했지만, 하위 클래스에서 메서드를 사용할 수 있다. 상위 클래스의 특성을 상속한다는 의미지 부모-자식 관계는 아니다. 
# 하위 클래스는 상위 클래스의 한 분류다. 

## 객체지향의 상속은 상위 클래스의 특성을 재사용하는 것이다. 
## 객체 지향의 상속은 클래스의 특성을 확장하는 것이다. 
## 객체 지향의 상속은 is a kind of 관계를 만족해야 한다.

# 다중상속과 자바
- 왜 자바는 다중 상속을 지원하지 않는가? 
- C++를 계승 발전 단순화 하면서 다중 상속을 빼버린 이유는?
- 인어공주 이야기 -> 인어에게 "수영해"라고 한다면 사람처럼 팔다리를 저어서 해야 하는지? 물고기 처럼 꼬리 지느러미로 헤엄쳐아 하는지? -> 다중 상속의 다이아몬드 문제 
- 대신 자바에서는 인터페이스를 도입해서 다중 상속의 득은 취하고 실은 과감히 버렸다.

# 상속과 인터페이스
- 인터페이스는 상속과 다르게 쓰는 것이 유용하다는 결론에 다다름. 
- 구현 클래스는 인터페이스 할 수 있다. 
- 상위 클래스는 항위 클래스에게 특성(속성과 메서드)을 상속해주고, 인터페이스는 클래스가 '무엇을 할 수 있다'라고 하는 기능을 구현하도록 강제 한다!! 
- Serializable 인터페이스, Cloneable 인터페이스, Comparable 인터페이스, Runnable 인터페이스

# Quiz
- 상위 클래스는 하위 클래스에게 물려줄 특성이 많을 수록 좋을까? 많을수록 -> LSP 리스코프 치환 원칙에 따라서
- 인터페이스는 구현을 강제할 메서드가 많을 수록 좋을까? 적을수록 -> ISP 인터페이스 분할 원칙에 따라서

# 인터페이스는 implements 키워드 사용, 구현 클래스에서 @Override 사용

## 상속과 T 메모리 꼭 기억!!!!
- 하위 클래스의 인스턴스가 생성될 때 상위 클래스의 인스턴스도 함께 힙 영역에 생성 된다. 

# ✅ 1. **암묵적 형변환 (Implicit Casting) — 업캐스팅(Upcasting)**

상위 클래스 타입으로 변환되는 것.

**자식 객체 → 부모 타입 변수**

자동으로 변환되며 데이터 손실이 없고 안전합니다.

---

## ✔ 특징

- **자동(암묵적)** 형변환
- 자식은 부모의 모든 특징을 가지고 있으므로 **문제 없이 변환 가능**
- 부모 타입으로 참조하면 부모가 가진 멤버(필드/메서드)만 사용 가능
- 실제 객체는 여전히 자식 객체

---

## ✔ 코드 예제

```java
class Parent {
    void show() { System.out.println("Parent show"); }
}

class Child extends Parent {
    void print() { System.out.println("Child print"); }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        Parent p = child; // 업캐스팅(암묵적 형변환)

        p.show();  // 가능 (Parent 메서드)
        // p.print(); // ❌ 불가능 (Child 메서드)
    }
}

```

---

## ✔ 이해 포인트

- `Parent p = new Child();` → 실제로는 Child 객체지만 Parent 타입으로 보겠다는 뜻
- **사용 가능한 멤버는 Parent가 가진 것만**
- 그러나 실제 객체는 Child이므로 **오버라이딩된 메서드는 Child의 것이 실행됨**

---

# ✅ 2. **명시적 형변환 (Explicit Casting) — 다운캐스팅(Downcasting)**

부모 타입을 다시 자식 타입으로 변환하는 것.

**부모 타입 변수 → 자식 타입 변수**

강제로 `(자식타입)` 캐스팅해야 하며, 조건이 맞지 않으면 오류가 발생할 수 있음.

---

## ✔ 특징

- **명시적** 캐스팅 필요
- 부모 타입이 실제로 **자식 객체일 때만** 가능
- 잘못된 다운캐스팅은 `ClassCastException` 발생

---

## ✔ 코드 예제

```java
Parent p = new Child(); // 업캐스팅
Child c = (Child) p;    // 다운캐스팅(명시적 형변환)

c.print(); // 가능 (Child 메서드)

```

---

## ✔ 잘못된 예 (예외 발생)

```java
Parent p = new Parent();
Child c = (Child) p; // ❌ ClassCastException 발생

```

**이유:** Parent 객체는 Child로 변할 수 없음.

---

# 🔄 3. 업캐스팅 vs 다운캐스팅 요약

| 비교항목 | 업캐스팅(암묵적) | 다운캐스팅(명시적) |
| --- | --- | --- |
| 캐스팅 타입 | 자식 → 부모 | 부모 → 자식 |
| 캐스팅 방식 | 자동 | 강제 `(Child)` 필요 |
| 안전성 | 안전함 | 위험, 예외 가능 |
| 가능 여부 | 항상 가능 | 실제 객체가 자식일 때만 가능 |
| 목적 | 일반화/유연성(OOP) | 자식 고유 기능 사용 |

---

# 📌 먼저 코드 요약

```java
Penguin pororo = new Penguin();
pororo.name = "뽀로로";
pororo.habitat = "남극";
pororo.showName();
pororo.showHabitat();

Animal pingu = new Penguin();
pingu.name = "핑구";
// pingu.habitat = "EBS";   // (16번 줄)

pingu.showName();
// pingu.showHabitat();     // (19번 줄)

// Penguin happyfeet = new Animal(); // (21번 줄)

```

---

# ✅ **16번 줄: `pingu.habitat = "EBS";` 가 왜 안 되는가?**

### ✔ 이유: **업캐스팅된 객체는 부모 클래스 멤버만 사용할 수 있기 때문**

`pingu`의 선언 타입을 보세요:

```java
Animal pingu = new Penguin();

```

여기서 **Penguin 객체를 생성했지만**, 참조 타입은 **Animal(부모)** 입니다.

이것이 **업캐스팅(암묵적 형변환)** 입니다.

### ❗ Animal 클래스에는 `habitat` 변수가 없음

- Penguin 클래스에는 `habitat`가 있음
- 하지만 부모 타입인 Animal에는 없음

따라서 **참조 변수 pingu는 Penguin의 멤버에 접근할 수 없다.**

👉 **pingu로 접근 가능한 것은 Animal의 멤버 뿐**

그래서 컴파일 에러 발생!

---

# ✅ **19번 줄: `pingu.showHabitat();` 가 왜 안 되는가?**

### ✔ 이유: 이것도 같은 원리 — 부모 타입에 없는 메서드는 호출 불가능

`showHabitat()` 메서드는 Penguin 클래스에만 있고,

Animal 클래스에는 정의되어 있지 않습니다.

업캐스팅을 하면:

- 실제 객체는 Penguin
- 그러나 **참조 타입이 Animal이므로 Animal에 없는 메서드는 호출 불가**

→ 컴파일러는 참조 변수 타입만 보고 판단합니다.

따라서 컴파일 오류 발생.

---

# 🔍 정리: 업캐스팅이란?

```
Penguin 객체 ----> Animal 타입 참조 변수

```

업캐스팅 후에는:

- 사용할 수 있는 멤버 = **Animal이 가진 멤버만**
- 사용할 수 없는 멤버 = **Penguin이 새로 추가한 멤버**

---

# ❌ 21번 줄: `Penguin happyfeet = new Animal();` 가 왜 안 되는가?

### ✔ 이유: **다운캐스팅이지만, 실제 객체 타입이 Penguin이 아니기 때문**

`Penguin happyfeet = new Animal();`

은 **부모 객체를 자식 타입 변수에 넣는 것**입니다.

자바에서는 이것을 **명시적 다운캐스팅**이라고 해도 불가능합니다.

### ❗ 왜냐하면?

Animal 객체는 **Penguin 타입이 아니기 때문**입니다.

즉,

```
Animal 객체 → Penguin 타입

```

이 변환은 **논리적으로 불가능**합니다.

### ⚠️ 다운캐스팅 규칙

자식 타입으로 캐스팅하려면 **실제 객체가 자식 타입**이어야 합니다.

예)

```java
Animal a = new Penguin();
Penguin p = (Penguin) a; // OK (실제 Penguin)

```

하지만 21줄은:

```java
Penguin happyfeet = new Animal();  // 불가능

```

실제 객체가 **Animal**이므로 Penguin으로 변환될 수 없습니다 → **컴파일 에러**

---

# 📌 결론 요약

| 줄 번호 | 코드 | 안 되는 이유 |
| --- | --- | --- |
| **16** | `pingu.habitat = "EBS";` | 업캐스팅 후 부모 타입에는 없는 변수 접근 불가 |
| **19** | `pingu.showHabitat();` | 업캐스팅 후 부모 타입에는 없는 메서드 호출 불가 |
| **21** | `Penguin happyfeet = new Animal();` | 부모 객체는 자식 타입이 될 수 없음 (다운캐스팅 불가) |

---

## 다형성 = 사용편의성
- oop에서 다형성은 오바라이딩과 오버로딩이라고 할 수 있다.
- 물론 상위 클래스와 하위 클래스 사이에서도 다형성을 이야기 할 수 있고, 인터페이스와 그것의 구현 클래스 사이에서도 다형성으르 이야기할 수 있지만, 가장 기본은 오버라이딩과 오버로딩이다.

# 오버라이딩-재정의: 상위 클래스의 메서드와 같은 메서드 이름, 같은 인자 리스트
# 오버로딩-중복정의: 같은 메서드 이름, 다른 인자(argument) 리스트
# 상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩(재정의)한 메서드가 호출 된다! 꼭 기억!!


## 캡슐화: 정보은닉
- private, default, protected, public

# 접근 제어자가 객체 멤버(인스턴스 맴버)와 쓰일 때와 정적 멤버(클래스 멤버)와 함께 쓰일 떄를 비교해서 살펴보자.
- public + 모두가 접근가능
- protected # 상속/같은 패키지 내의 클래스에서 접근 가능
- [default] ~ 같은 패키지 내의 클래스에서 접근 가능
- private - 본인만 접근 가능
# protected가 자신과 상속 관계에 있는 서브 클래스만 접근 가능한 것으로 착각 하는 경우가 많다. 하지만 같은 패키지라면 접근 가능하다!
# aa.jar, bb.jar 에 이름이 같은 패키지가 있다면 어떻게 될까? 각각의 패키지에서 상대방 패키지(그러나 이름은 같은) 내 클래스나 객체가 가진 public 멤버 뿐 만 아니라, [default]멤버와 protected 멤버에 자유럽게 접근 가능하다. 
- 보안에 신경 쓸 것!!

## 상속을 받지 않았따면 객체 멤버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야 한다. 
## 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장한다.객체를 생성 후 객체참조변수명.정적멤버 형태로도 접근 가능 하지만 메모리 물리적인 이유로 권장하지 않는다.(참조 변수를 통해 static 멤버에 접근해도, JVM은 결국 Method Area의 static count 주소로 이동한다)

아래에 **자바 접근 제어자(Access Modifier)**를

① **객체 멤버(인스턴스 변수·인스턴스 메서드)**

② **정적 멤버(static 변수·static 메서드)**

두 가지 관점으로 **명확하게 구분해서 정리**해드릴게요.

---

# 📌 자바의 접근 제어자 4종류

| 접근 제어자 | 접근 범위 |
| --- | --- |
| `public` | 어디서나 접근 가능 |
| `protected` | 같은 패키지 + 자식 클래스 |
| (default) | 같은 패키지 내부 |
| `private` | 클래스 내부에서만 |

---

# ✅ 1. **객체 멤버에 대한 접근 제어자**

(인스턴스 변수 / 인스턴스 메서드)

객체 멤버는 **객체마다 따로 존재**하고, **객체를 통해서 접근**합니다.

### ✔ 정리 표

| 접근 제어자 | 객체 멤버 접근 가능 범위 | 설명 |
| --- | --- | --- |
| **public** | 어떤 객체든 접근 가능 | 객체가 다른 패키지에 있어도 접근 가능 |
| **protected** | 같은 패키지 객체 + 상속받은 자식 객체 | 부모의 protected 멤버는 자식 객체가 접근 가능 |
| **default** | 같은 패키지의 객체만 접근 | 패키지가 다르면 접근 불가 |
| **private** | 같은 객체 내부에서만 | 객체 간에도 접근 불가 (같은 클래스라도 다른 객체면 불가) |

### ✔ 예시 – 객체 멤버

```java
class Person {
    public String name;        // 누구나 접근 가능
    protected int age;         // 같은 패키지 or 자식 클래스
    String address;            // default — 같은 패키지
    private String id;         // 클래스 내부에서만
}

```

---

# ✅ 2. **정적 멤버(static 멤버)에 대한 접근 제어자**

(static 변수 / static 메서드)

정적 멤버는 **클래스가 소유**하며, 객체 없이 **클래스명으로 접근**합니다.

정적 멤버도 객체 멤버와 동일한 접근 제어자가 적용되지만,

**접근 방식과 의미는 다르게 해석됩니다.**

### ✔ 정리 표

| 접근 제어자 | 정적 멤버 접근 가능 범위 | 설명 |
| --- | --- | --- |
| **public static** | 어디서나 클래스명으로 접근 가능 | 라이브러리의 유틸 함수 방식 |
| **protected static** | 같은 패키지 + 자식 클래스 | 자식 클래스는 부모의 static에 접근 가능 |
| **default static** | 같은 패키지 | 외부 패키지는 접근 불가 |
| **private static** | 같은 클래스 내부에서만 | 클래스 외부에서는 호출 불가 |

### ✔ 예시 – static 멤버

```java
class Counter {
    public static int totalCount;      // 어디든 접근 가능
    protected static int protectedData; // 같은 패키지 + 자식
    static int defaultData;             // 같은 패키지
    private static int secret;          // 클래스 내부
}

```

---

# 🔍 **객체 멤버 vs 정적 멤버 — 접근 제어자 관점 차이**

| 구분 | 객체 멤버 | 정적 멤버 |
| --- | --- | --- |
| 존재 위치 | 객체(Heap) | 클래스(Method Area) |
| 접근 방법 | 객체참조변수.멤버 | 클래스명.멤버 (객체로도 가능하지만 비추천) |
| 접근 제어자 의미 | “객체 간의 접근 가능 여부 결정” | “클래스 단위로 접근 가능한지 결정” |
| private 의미 | 객체 간에도 접근 불가 | 클래스 내부에서만 접근 가능 (클래스 외부 완전 차단) |

---

# 🔥 핵심 포인트 요약

### ✔ 객체 멤버

- 접근 제어자가 **객체 간 접근을 제어**한다.
- `private` 인 멤버는 **같은 클래스라도 다른 객체에서 접근 불가**.

### ✔ 정적 멤버

- 접근 제어자가 **클래스 단위의 접근을 제어**한다.
- `private static`은 **외부에서 클래스명으로 접근 자체 불가**.

---

## 참조변수의 복사
- 기본 자료형 변수는 값을 값 자체로 판단한다. 
- 참조 자료형 변수는 값을 주소, 즉 포인터로 판단한다. 
- 기본 자료형 변수를 복사할 때, 참조 자료형 변수를 복사할 때 일어나는 일은 같다. 즉, 가지고 있는 값을 그대로 복사해서 넘겨준다.
- 기본 자료형 변수의 복사를하든 참조 변수를 복사하든 결국은 변수가 가진 값이 그대로 복사된다. 결국 그 값을 값 자체ㅐ로 해석하느냐 아니면 주소값으로 해석하느냐의 차이일 뿐이다.

### 🔹 **자바는 *무조건* Call by Value이다.**

하지만 여기서 “value(값)”이 **객체 자체가 아니라 객체의 주소값(참조)** 일 뿐이다.

그래서 헷갈리는 상황이 생긴다.

---

# 🔍 1. 기본 타입(Primitive type)은 진짜 값이 복사된다

```java
void change(int x) {
    x = 10;
}

public static void main(String[] args) {
    int a = 5;
    change(a);
    System.out.println(a); // 👉 5
}

```

### ✔ 이유

`a`의 값인 **5가 복사**되어 전달된다.

메서드 안에서 아무리 바꿔도 **원본 a와는 별개**이다.

---

# 🔍 2. 객체(Object)는 “참조값(주소)”이 복사된다

```java
void changeValue(Dog d) {
    d.name = "Happy";
}

public static void main(String[] args) {
    Dog dog = new Dog("Coco");
    changeValue(dog);
    System.out.println(dog.name); // 👉 Happy
}

```

### ✔ 이유

`dog` 객체 자체를 넘기는 것이 아니라,

**객체가 저장된 힙 메모리 주소값이 복사**되어 전달된다.

그래서 함수 안에서 `Dog`의 속성을 바꾸면

**같은 객체를 바라보고 있어서** 원본이 변한다.

---

# ❗ 하지만 여기서 중요한 포인트

### 📌 객체 참조 자체를 바꾸면 원본에 영향 없음

```java
void changeObj(Dog d) {
    d = new Dog("Bobby");
}

public static void main(String[] args) {
    Dog dog = new Dog("Coco");
    changeObj(dog);
    System.out.println(dog.name); // 👉 Coco
}

```

### ✔ 이유

메서드 안에서 `d`는 **복사된 참조값**이므로

`d = new ...`은 그 복사본을 새로운 객체로 바꾼 것일 뿐.

원본 `dog`은 그대로 `"Coco"`를 가리킨다.

---

# 🎯 핵심 요약

| 데이터 종류 | 함수에 전달되는 것 | 원본 변경 여부 |
| --- | --- | --- |
| 기본형(int, double…) | **실제 값** | ❌ 변경 없음 |
| 객체(Object) | **참조값(주소)의 복사본** | ⭕ 속성은 변경됨 |
| 객체 참조 자체 변경 | 참조값의 복사본 | ❌ 원본 영향 없음 |

---

# 💡 한 문장 정리

> 자바는 항상 Call by Value지만, 객체를 넘길 때는 "주소값의 복사"이기 때문에 마치 Call by Reference처럼 보일 때가 있다.

---

자바(Java)에서 **Call by Value**와 **Call by Reference** 개념이 헷갈리신다면, 이는 자바가 **모든 것을 Call by Value 방식으로 처리**하지만, 그 "값(Value)"이 **기본 타입**이냐 **참조 타입**이냐에 따라 동작이 다르게 보이기 때문입니다.

결론부터 말씀드리면:

> 자바는 원칙적으로 언제나 'Call by Value' 방식만 사용합니다.

## 1. 🥇 Call by Value (값에 의한 호출)

**Call by Value**는 메서드를 호출할 때 **인자로 전달되는 변수의 '값' 자체를 복사**하여 전달하는 방식입니다.

### 동작 원리:

1. 메서드를 호출하면, 원본 변수(호출자)가 가지고 있는 **값**을 복사합니다.
2. 이 **복사된 값**이 매개변수(피호출자)에 전달됩니다.
3. 메서드 내부에서 매개변수의 값을 아무리 변경해도, **원본 변수의 값은 전혀 영향을 받지 않습니다.**

### A. 기본 타입 (Primitive Types)일 경우

`int`, `double`, `boolean` 등 **기본 타입**의 변수를 전달할 때는 **실제 데이터 값**이 복사되어 전달됩니다.

- **예시:**
```java
    
    public static void changeInt(int num) {
        num = 100; // 복사된 값(num)만 100으로 변경됨
    }
    
    int original = 10;
    changeInt(original);
    // original 값은 여전히 10. 메서드 내부의 변경은 original에 영향을 주지 않음.`
    
    이 경우, **Call by Value**의 전통적인 동작이 그대로 나타나기 때문에 이해하기 쉽습니다.
```

---

## 2. 🥈 참조 타입 (Reference Types)일 경우

헷갈림은 여기서 발생합니다. `String`, `Object`, 배열 등 **참조 타입**의 변수를 전달할 때도 자바는 여전히 **Call by Value**를 사용합니다.

### 동작 원리:

1. 참조 타입 변수가 가지고 있는 **'값'**은 객체가 저장된 **메모리 주소**입니다.
2. 메서드를 호출하면, 이 **메모리 주소(참조값)가 복사**되어 매개변수에 전달됩니다.
3. 매개변수는 원본 변수와 **같은 객체를 가리키게 됩니다.**

### A. 객체 자체를 수정하는 경우 (Call by Reference처럼 보이는 경우)

메서드 내부에서 복사된 참조값(`p`)을 사용하여 객체의 **내부 상태(필드)**를 변경하면, 원본 변수(`person`)가 가리키는 객체 자체가 수정됩니다. 이는 마치 **Call by Reference**처럼 보입니다.

- **예시:**
``` Java
    
    public class Person {
        String name;
    }
    public static void changeName(Person p) {
        p.name = "Alice"; // 객체 내부 필드 수정
    }
    
    Person person = new Person("Bob");
    changeName(person);
    // person 객체의 name 필드는 "Alice"로 변경됨. (Call by Reference처럼 보임)`
```    

### B. 참조값 자체를 변경하는 경우 (여전히 Call by Value임을 증명)

만약 메서드 내부에서 매개변수(`p`)에 **새로운 객체의 주소**를 할당하면, 원본 변수(`person`)에는 전혀 영향을 주지 않습니다. 이는 자바가 **Call by Value**임을 명확히 보여줍니다.

- **예시:**
``` Java
    
    public static void createNewPerson(Person p) {
        p = new Person("NewGuy"); // p가 새로운 객체를 가리키도록 변경됨
    }
    
    Person person = new Person("OldGuy");
    createNewPerson(person);
    // person은 여전히 "OldGuy" 객체를 가리킴. (Call by Value임이 증명됨)`
```

---

## 💡 결론 및 핵심 요약

| **개념** | **Call by Value (Java의 모든 타입)** | **Call by Reference (C/C++ 포인터)** |
| --- | --- | --- |
| **전달되는 것** | 변수의 **'값' 복사** (기본값 또는 주소값) | 변수 **자체의 주소** (원본을 직접 지정) |
| **메서드 내 변경** | 복사된 **값만 변경** (원본 영향 없음) | **원본 변수 자체를 변경**할 수 있음 |
| **자바에서** | **항상** 이 방식을 사용합니다. | **공식적으로 지원하지 않습니다.** |

헷갈림을 없애려면 이렇게 기억하세요:

> 자바에서 메서드에 무언가를 전달하면, 그 무언가의 주소가 전달되는 것이 아니라 그 **무언가가 담고 있는 내용(값)**이 복사되어 전달됩니다. 그 내용이 기본 데이터(10, 3.14)이면 그 데이터가 복사되고, 객체에 대한 주소이면 그 주소값이 복사되는 것입니다.
>