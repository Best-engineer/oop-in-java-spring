# Chapter1 사람을 사랑한 기술

## 🧩 프로그래밍 언어 비교 테이블

| 구분 | **기계어 (Machine Code)** | **어셈블리어 (Assembly)** | **C** | **C++** | **Java** |
| --- | --- | --- | --- | --- | --- |
| **개발자의 코딩** | 없음(0과 1 작성 불가) | 니모닉(mov, add 등)과 약간의 일상 단어 | C 문법 기반, 절차적 언어 | C 문법 + 객체지향 문법 | Java 문법, 완전 고수준 문법 |
| **소스 파일** | 없음 | CPU마다 다름(ISA 의존) | 기종이 몇 개든 `.c` 파일은 동일 | 기종 상관없이 동일 `.cpp` | 기종 상관없이 동일 `.java` |
| **목적 파일** | 없음(바로 기계어) | 어셈블러가 CPU별 기계어 생성 | 컴파일러가 각 OS/CPU용 기계어 생성 | 컴파일러가 각 OS/CPU용 기계어 생성 | 컴파일러가 **바이트코드(.class)** 생성(기종 1개) |
| **기계어 비교** | 기계어 자체 | 기계어와 **1:1 대응**(각 명령에 딱 1개의 니모닉) | 한 문장이 여러 기계어 명령으로 바뀜 → **1:N 대응** | 한 문장이 여러 기계어로 바뀜 + 템플릿/객체 등으로 더 복잡 → **1:N 대응** | 바이트코드와 1:N 대응. (바이트코드는 JVM이 다시 N개의 기계어로 변환) |
| **비고** | CPU가 바로 실행 | CPU별 어셈블러 필요 | CPU/OS별 컴파일러 필요 | CPU/OS별 컴파일러 필요 | 컴파일러는 하나면 되고, 기종별 JVM만 필요 |
| **언어 수준** | 가장 낮음(0/1) | 저수준(Low-level) | 중저수준 | 중간~고수준 | 고수준 |
| **실행 방식** | CPU가 직접 실행 | 어셈블러로 기계어로 변환 | 컴파일 → 기계어 | 컴파일 → 기계어 | 컴파일 → 바이트코드 → JVM 실행 |
| **이식성(Portability)** | 거의 없음(CPU 종속) | 낮음(CPU 종속) | 중간(플랫폼 맞춰 재컴파일 필요) | 중간~높음 | 매우 높음(Write Once, Run Anywhere) |
| **속도** | 가장 빠름 | 매우 빠름 | 빠름 | 빠름 | 보통(JVM에 의해 좌우) |
| **코딩 난이도** | 매우 어려움 | 어려움 | 보통 | 보통~어려움 | 쉬움 |
| **메모리 관리** | 전부 수동 | 수동 | 수동 | 수동 및 RAII 지원 | 가비지 컬렉션 자동 |
| **주 사용 분야** | 하드웨어 제어, 펌웨어 | 임베디드, OS 커널 일부 | 시스템 프로그래밍, 임베디드 | 대규모 소프트웨어, 게임, 시스템 | 모바일, 웹, 기업용 시스템 |
| **장점** | 최고 성능, 직접 하드웨어 제어 | 빠른 속도, 하드웨어 최적화 | 속도 빠름, C 기반 시스템의 표준 | 객체지향 + 성능 | 높은 이식성, 안정성 |
| **단점** | 사람이 읽기 어려움 | 유지보수 어려움 | 안전성 낮음(포인터 오류 등) | 복잡함 | 성능이 네이티브 언어보다 낮을 수 있음 |
| **대표 활용 예** | CPU 명령 실행 | BIOS, 드라이버 | OS, 임베디드 | 게임엔진, 앱 | Android, 서버, 플랫폼 개발 |

---

## 🔎 요약 정리

- **기계어**: 컴퓨터가 직접 이해하는 0과 1. 가장 빠르고 가장 어렵다.
- **어셈블리어**: 기계어의 영어 버전. 하드웨어 제어가 필요할 때 사용한다. -> 인간의 언어로 프로그램 작성이 가능하게 해줬다.
- **C**: 시스템 프로그래밍의 표준. 빠르고 강력하지만 위험할 수 있다. -> 하나의 소스로 이기종 간에 이식성을 확보했다.
- **C++**: C 기반 + 객체지향 + 고성능. 대형 프로젝트에서 많이 쓰임. -> 객체 지향 개념을 도입했다. 
- **Java**: JVM 기반 고수준 언어. 안정적, 이식성이 좋아 기업에서 선호. -> 한번의 컴파일로 이기종 간에 이식성을 확보했다. 포인터에 대한 개념 없이 프로그래밍을 가능하게 했다. 
- **스프링 프레임워크**: 스프링은 Ioc/DI, AOP, PSA라고 하는 객체 지향의 베스트 프랜티스만으로 아무리 거대한 프로그램이라도 쉽게 구현할 수 있음을 보여준 프레임 워크다. -> 스프링은 객체지향 위에 서있다.

---

## ✅ 1. **CBD (Component-Based Development)**

**컴포넌트 기반 개발**

→ 소프트웨어를 **재사용 가능한 컴포넌트 단위로 조립하듯이 개발**하는 방법.

### ✔ 개념

- 소프트웨어를 **작고 독립된 기능 단위(Component)**로 나누어 개발하고
- 필요한 곳에서 **조립(plug & play)**하여 시스템을 만드는 개발 방식.

### ✔ 특징

- 컴포넌트는 재사용 가능
- 독립적으로 개발·테스트 가능
- 유지보수 용이
- 특정 기능만 교체하거나 업그레이드 가능

### ✔ 예시

- 로그인 모듈, 결제 모듈, 알림 모듈 같은 **재사용 가능한 기능 덩어리**
- React/Vue 컴포넌트 시스템과 유사한 개념

---

## ✅ 2. **SOA (Service-Oriented Architecture)**

**서비스 지향 아키텍처**

→ 시스템을 **서비스 단위(비즈니스 기능 단위)**로 분리하고,

서로 **표준화된 메시지(HTTP, SOAP, REST 등)**를 통해 호출하는 구조.

### ✔ 개념

- 서비스란, **독립된 비즈니스 기능 단위**
    
    (예: 결제 서비스, 배송 서비스, 인증 서비스)
    
- 서비스 간에는 **네트워크를 통해 통신**
- 서로 다른 언어나 플랫폼에서도 호출 가능

### ✔ 특징

- 낮은 결합도(Loose Coupling)
- 비즈니스 중심 서비스 설계
- 대규모 기업 시스템에서 많이 사용
- 변경에 강하고 확장에 유리

### ✔ 예시

- 웹 서비스 기반 아키텍처(REST API, SOAP API 등)
- “배송 시스템이 결제 시스템을 호출” 같은 구조

---

## 🔎 CBD vs SOA 차이

| 구분 | CBD | SOA |
| --- | --- | --- |
| 단위 | 컴포넌트(Component) | 서비스(Service) |
| 목적 | 재사용성, 유지보수 용이 | 분산 시스템 확장, 플랫폼 독립성 |
| 호출 방식 | 내부 호출(라이브러리 형태) | 외부 호출(네트워크 기반 API) |
| 사용 형태 | 프로그램 내부 구성 요소 | 시스템 간 협업(기업 규모) |
| 예 | UI 컴포넌트, 기능 모듈 | REST API, 마이크로서비스 |

---

## 📌 가장 쉽게 요약

- **CBD**: 프로그램 안을 부품(컴포넌트) 조립하듯이 만든다. -> 제품이 아니다. 제품이 없다!. 사상일뿐! 그래서 이해하기 힘듦
- **SOA**: 프로그램들끼리 서비스를 주고받으며 협업하는 방식. 개발자 입장에서의 개발이 아니라 실제 현실의 업무를 기준으로 개발하자는 사상 -> 제품이 없다! 사상일 뿐! 그래서 이해하기 힘듦

---

## 🧩 스프링 프레임 워크는 사상이면서 또 단일 제품이다. 

### 스프링의 근원적 요소

### ✅ 1. POJO (Plain Old Java Object)

**그냥 평범한 자바 객체.**

특별한 상속, 규칙, 프레임워크 종속 코드 없이

그냥 우리가 new 해서 쓰는 순수한 자바 클래스.

📌 예)

```java
public class Member {
    private String name;
}

```

✔ 스프링은 이런 **순수 자바 객체를 기반으로 개발하자** 라는 철학을 가짐.

→ 프레임워크 종속 코드가 없어서 테스트, 유지보수가 쉬움.

---

### ✅ 2. IoC / DI

### ✔ IoC (Inversion of Control, 제어의 역전)

원래 개발자가 객체를 생성하고 연결해야 했지만,

**스프링이 대신 객체를 만들고 주입해주는 구조**.

→ 즉, 객체 제어권이 “개발자 → 스프링 프레임워크”로 넘어감.

### ✔ DI (Dependency Injection, 의존성 주입)

스프링이 만든 객체를 필요한 곳에 **넣어주는 것**.

IoC의 구현 방식 중 하나.

📌 예)

```java
// 개발자가 new 하지 않음!
@Autowired
private MemberService memberService;

```

### ✅ 1. IoC(Inversion of Control) = “제어의 역전”

원래는 개발자가 직접 객체를 만들고 연결해야 함.

### 🔥 IoC가 없는 일반 Java

```java
public class MemberController {
    private MemberService service = new MemberService(); // 직접 생성
}

```

📌 객체 생성 제어권이 **개발자에게 있음**

---

### 🔥 IoC가 있는 스프링

```java
@Controller
public class MemberController {
    private final MemberService service;

    public MemberController(MemberService service) {  // 스프링이 넣어줌
        this.service = service;
    }
}

```

📌 객체 생성·관리 제어권이 **스프링에게 있음**

개발자는 연결만 받아서 사용함.

➡ **이 제어의 흐름이 뒤바뀐 것 = IoC**

---

### ✅ 2. DI(Dependency Injection) = “의존성 주입”

스프링이 만들어둔 객체를(Bean)

필요한 곳에 **넣어주는 것**.

즉, IoC의 구현 방식 중 하나.

---

### 🔥 DI의 세 가지 방식

### ✔ 1) 생성자 주입(가장 권장)

```java
@Service
public class MemberController {
    private final MemberService service;

    public MemberController(MemberService service) {
        this.service = service;   // 주입!
    }
}

```

스프링이 MemberService 객체를 만들어서

**생성자 파라미터로 자동 주입해줌.**

---

### ✔ 2) 필드 주입 (비추천)

```java
@Autowired
private MemberService service;

```

테스트가 어려워서 잘 안 씀.

---

### ✔ 3) Setter 주입

```java
@Autowired
public void setService(MemberService service) {
    this.service = service;
}

```

동적으로 변경해야 할 때 사용.

---

### ✅ 3. AOP (Aspect-Oriented Programming, 관점 지향 프로그래밍)

핵심 기능과는 상관 없는 **공통 기능을 분리하는 방식**.

예)

- 로깅
- 보안
- 트랜잭션 관리
- 실행 시간 측정

✔ 핵심 비즈니스 로직에 이런 코드 섞기 싫으니까

→ 스프링이 대신 “옆에서 끼워 넣기” 해줌.
→ 스프링이 내부적으로 AOP 기술을 이용해서 개발자가 매번 구현할 필요 없는 공통 기능을 자동으로 제공함.

📌 예) @Transactional, @Async, @Cacheable, @Scheduled

→ 메서드 실행 전/후로 트랜잭션을 자동 처리 (AOP 기반)

---

### ✅ 4. PSA (Portable Service Abstraction)

**같은 기능을 다른 기술로 구현하더라도,
스프링은 같은 방식으로 사용할 수 있게 추상화해주는 것.**

예)

- 스프링 MVC의 `@RequestMapping`
    - 내부적으로 톰캣/Jetty/Netty 어떤 서버든 동일하게 사용 가능
- 트랜잭션 관리 `@Transactional`
    - JDBC, JPA, Hibernate 어떤 기술이든 같은 어노테이션 사용

✔ 즉, 개발자는 기술을 바꿔도 **스프링 방식은 그대로 유지된다**.

### 📌 초간단 한 줄 요약

| 개념 | 한 줄 요약 |
| --- | --- |
| **POJO** | 그냥 평범한 자바 클래스 |
| **IoC/DI** | 객체 생성/주입을 스프링이 대신함 |
| **AOP** | 공통 기능을 자동으로 끼워 넣기 |
| **PSA** | 기술이 달라도 같은 방식으로 사용 |